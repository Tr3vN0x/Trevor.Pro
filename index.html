<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Survivor TPS</title>
    <style>
        body { margin: 0; background: #020205; overflow: hidden; font-family: 'Orbitron', sans-serif; }
        canvas { display: block; }
        #ui {
            position: absolute; top: 20px; left: 20px; color: #00f2ff;
            pointer-events: none; font-family: monospace; font-size: 18px;
        }
        .bar { width: 200px; height: 10px; background: #111; border: 1px solid #00f2ff; margin-top: 5px; }
        #hp-fill { width: 100%; height: 100%; background: #00f2ff; transition: 0.2s; }
    </style>
</head>
<body>

    <div id="ui">
        <div>KILLS: <span id="kills">0</span></div>
        <div>AMMO: <span id="ammo">âˆž</span></div>
        <div class="bar"><div id="hp-fill"></div></div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const hpFill = document.getElementById('hp-fill');
    const killEl = document.getElementById('kills');

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // --- GAME WORLD SETTINGS ---
    const world = { width: 3000, height: 3000 };
    let kills = 0;
    let health = 100;

    const player = {
        x: world.width / 2,
        y: world.height / 2,
        size: 25,
        speed: 4,
        angle: 0
    };

    const camera = { x: 0, y: 0 };
    const bullets = [];
    const enemies = [];
    const keys = {};

    // Input Listeners
    window.addEventListener('keydown', e => keys[e.code] = true);
    window.addEventListener('keyup', e => keys[e.code] = false);
    window.addEventListener('mousemove', e => {
        const dx = e.clientX - canvas.width / 2;
        const dy = e.clientY - canvas.height / 2;
        player.angle = Math.atan2(dy, dx);
    });
    window.addEventListener('mousedown', shoot);

    function shoot() {
        bullets.push({
            x: player.x,
            y: player.y,
            vx: Math.cos(player.angle) * 10,
            vy: Math.sin(player.angle) * 10,
            life: 100
        });
    }

    class Mob {
        constructor() {
            this.x = Math.random() * world.width;
            this.y = Math.random() * world.height;
            this.speed = 2 + Math.random() * 2;
            this.hp = 2;
        }
        update() {
            const dx = player.x - this.x;
            const dy = player.y - this.y;
            const dist = Math.hypot(dx, dy);
            this.x += (dx / dist) * this.speed;
            this.y += (dy / dist) * this.speed;

            if (dist < player.size) {
                health -= 0.2;
                hpFill.style.width = health + "%";
            }
        }
    }

    function spawnEnemies() {
        if(enemies.length < 50) enemies.push(new Mob());
        setTimeout(spawnEnemies, 1000 - (kills * 5));
    }

    function update() {
        // Movement
        if (keys['KeyW'] || keys['ArrowUp']) player.y -= player.speed;
        if (keys['KeyS'] || keys['ArrowDown']) player.y += player.speed;
        if (keys['KeyA'] || keys['ArrowLeft']) player.x -= player.speed;
        if (keys['KeyD'] || keys['ArrowRight']) player.x += player.speed;

        // Keep player in world
        player.x = Math.max(0, Math.min(world.width, player.x));
        player.y = Math.max(0, Math.min(world.height, player.y));

        // Camera Follow
        camera.x = player.x - canvas.width / 2;
        camera.y = player.y - canvas.height / 2;

        // Update Bullets
        bullets.forEach((b, i) => {
            b.x += b.vx; b.y += b.vy; b.life--;
            if (b.life <= 0) bullets.splice(i, 1);
            
            // Hit detection
            enemies.forEach((e, ei) => {
                if (Math.hypot(b.x - e.x, b.y - e.y) < 20) {
                    e.hp--;
                    bullets.splice(i, 1);
                    if(e.hp <= 0) {
                        enemies.splice(ei, 1);
                        kills++;
                        killEl.innerText = kills;
                        if(health < 100) health += 2;
                    }
                }
            });
        });

        enemies.forEach(e => e.update());
        if (health <= 0) location.reload();
    }

    function draw() {
        ctx.fillStyle = '#020205';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.save();
        ctx.translate(-camera.x, -camera.y);

        // Draw Grid Map
        ctx.strokeStyle = '#11112b';
        ctx.lineWidth = 2;
        for (let i = 0; i <= world.width; i += 100) {
            ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, world.height); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(world.width, i); ctx.stroke();
        }

        // Draw Player
        ctx.save();
        ctx.translate(player.x, player.y);
        ctx.rotate(player.angle);
        ctx.fillStyle = '#00f2ff';
        ctx.shadowBlur = 15; ctx.shadowColor = '#00f2ff';
        ctx.fillRect(-15, -15, 30, 30); // Body
        ctx.fillStyle = '#fff';
        ctx.fillRect(10, -5, 15, 10); // Gun barrel
        ctx.restore();

        // Draw Enemies
        ctx.shadowBlur = 10; ctx.shadowColor = '#ff0055';
        ctx.fillStyle = '#ff0055';
        enemies.forEach(e => {
            ctx.beginPath();
            ctx.arc(e.x, e.y, 15, 0, Math.PI*2);
            ctx.fill();
        });

        // Draw Bullets
        ctx.fillStyle = '#fff';
        bullets.forEach(b => ctx.fillRect(b.x, b.y, 6, 6));

        ctx.restore();
        requestAnimationFrame(() => { update(); draw(); });
    }

    spawnEnemies();
    draw();

    window.onresize = () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    };
</script>
</body>
</html>
